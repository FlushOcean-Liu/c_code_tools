/*
共享对象读写不均衡，多读少写，多写少读

rwlock 主要有以下几种特征：
多进程对临界区的读不互斥，可同步进行，互不影响
如果要执行写，需要等所有的读者退出才能执行写操作
如果正在执行写操作且未完成，这一阶段发生的读操作会被阻塞，即读写互斥
如果正在执行写操作且未完成，这一阶段发生的读操作会被阻塞，即写写互斥
不造成睡眠，等待形式是自旋

*/

// write_lock/write_unlock
/*
write_lock 的实现正如上文中介绍的那样：
判断并等待 rw->lock 为 0，如果不为 0，表示有其它进程正在读或者写，这时候让 CPU 休眠，read_unlock 和 write_unlock 都会在适当的时机发送唤醒事件
如果 rw->lock 为 0，就将 rw->lock 的最高位设置为 1，表示当前进程正在操作，你们等着吧。
 最后，添加一个内存屏障，表示加锁后的代码不会乱序排到加锁之前执行。 
*/
